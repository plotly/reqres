---
output:
  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# reqres

[![Travis-CI Build Status](https://travis-ci.org/thomasp85/reqres.svg?branch=master)](https://travis-ci.org/thomasp85/reqres)
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/thomasp85/reqres?branch=master&svg=true)](https://ci.appveyor.com/project/thomasp85/reqres)
[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version-ago/reqres)](https://cran.r-project.org/package=reqres)
[![CRAN_Download_Badge](http://cranlogs.r-pkg.org/badges/reqres)](https://cran.r-project.org/package=reqres)
[![Coverage Status](https://img.shields.io/codecov/c/github/thomasp85/reqres/master.svg)](https://codecov.io/github/thomasp85/reqres?branch=master)

While the http protocol is rather basic in essence, it can be a pain to work 
with. `reqres` is here to soothe the pain somewhat by providing two powerful
classes for handling all parts of request and response handling during a http
exchange. *This is not a web server*, instead it focuses on making life easier
for developers of web servers by extracting the complexity of cookies, headers,
content negotiation, and the likes into neat little classes. `reqres` builds
upon the [`rook`](https://github.com/jeffreyhorner/Rook/blob/a5e45f751/README.md)
specifications and is thus well suited for 
[`httpuv`-based](https://github.com/rstudio/httpuv) webservers.

## Features
`reqres` draws a lot of inspiration from [express.js](https://expressjs.com) and
the `Request` and `Response` classes is aiming for feature parity with those 
from express. The `Request` class provides automatic parsing of the query string
along with parsing of the body based on the `Content-Type` header (with 
decompression if `Content-Encoding` is provided). Further, it provides content
negotiation based on the `Accept(-*)` headers. The `Response` class allows you
to set headers and cookies easily, assign arbitrary data for later use, and
automatically format the body based on content negotiation with the `Request`
object that it is responding to (again, it will compress automatically if the 
`Accept-Encoding` header allows it). If any part of the content negotiation 
fails the correct response status code will be set, making the response ready to
send.

`reqres` comes with a range of parsers and formatters making it work out of the 
box with json, xml, html, csv, tab, multipart, and www-form-urlencoded payloads.
It is easy to either modify these or provide your own parsers and formatters if
needed - `reqres` will take care of the content negotiation and simply call your
custom parser/formatter if chosen.

## Demo
Below is a quick demo of some of the features in `reqres`. It uses the 
`fake_request()` in `fiery` to mock a rook request so it can be used without
setting up a webserver:

```{r}
library(reqres)

# We start by mocking our request
rook <- fiery::fake_request(
    url = 'http://www.example.com/summary?id=2347&user=Thomas+Lin+Pedersen',
    content = '{"name":["Thomas Lin Pedersen"],"age":[31],"homepage":["www.data-imaginist.com","www.github.com/thomasp85"]}',
    headers = list(
        Content_Type = 'application/json',
        Accept = 'application/json, application/xml; q=0.5, text/*; q=0.3',
        Accept_Encoding = 'gzip, br'
    )
)

# A Request object can now be created
req <- Request$new(rook)
req

# ... along with a response
res <- req$respond()
res

# A lot of information is already available, e.g.
req$host
req$query

# But the body is not filled in automatically
req$body

# This needs to be parsed. The Content-Type header gives the type
req$is('json')
req$parse(json = parse_json())
req$body

# You don't need to do this manually though. Just supply multiple
# and the correct will be chosen
req$set_body(NULL)
req$parse(
    txt = parse_plain(), 
    html = parse_html(), 
    json = parse_json()
)
req$body

# If no parser fits the bill the correct error code will be set
# on the response
req$set_body(NULL)
req$parse(txt = parse_plain())
res

# To make it easy, reqres comes with a mapping of common mime types
req$set_body(NULL)
req$parse(default_parsers)
req$body

# The response allow you to easily set headers, cookies, etc
res$set_header('Date', to_http_date(Sys.time()))
res$get_header('Date')
res$set_cookie('user', req$query$id, max_age = 9000L)
res$get_header('Set-Cookie')

# It also has a data store where arbitrary data can be passed along
# between different middleware. This data will never become part of
# the actual response
res$set_data('alphabet', letters)
res$get_data('alphabet')

# Files can be attached for download and the relevant headers will be filled
# out for you
res$attach(system.file('NEWS.md', package = 'reqres'))
res$get_header('Content-Type')
res$get_header('Content-Disposition')

# Lastly we can manipulate the body
res$remove_header('Content-Disposition')
res$body <- head(mtcars)
res$body

# Based on the Accept header in the request it can be formatted correctly
# As the request contains an Accept-Encoding header it will be compressed 
# as well
res$format(json = format_json())
res$body
res$get_header('Content-Type')
res$get_header('Content-Encoding')

# The content negotiation understands wildcards etc
res$body <- head(mtcars)
req$get_header('Accept')
res$format(csv = format_table(sep = ','), compress = FALSE)
res$body
res$get_header('Content-Type')

# As with request parsing, a default mapping exists for your use.
res$body <- head(mtcars)
res$format(default_formatters, compress = FALSE)
res$body
```

